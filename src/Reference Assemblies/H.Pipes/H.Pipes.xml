<?xml version="1.0"?>
<doc>
    <assembly>
        <name>H.Pipes</name>
    </assembly>
    <members>
        <member name="T:H.Pipes.Args.ConnectionEventArgs`1">
            <summary>
            Handles new connections.
            </summary>
            <typeparam name="T">Reference type</typeparam>
        </member>
        <member name="P:H.Pipes.Args.ConnectionEventArgs`1.Connection">
            <summary>
            Connection
            </summary>
        </member>
        <member name="M:H.Pipes.Args.ConnectionEventArgs`1.#ctor(H.Pipes.PipeConnection{`0})">
            <summary>
            
            </summary>
            <param name="connection"></param>
        </member>
        <member name="T:H.Pipes.Args.ConnectionExceptionEventArgs`1">
            <summary>
            Handles exceptions thrown during read/write operations.
            </summary>
            <typeparam name="T">Reference type</typeparam>
        </member>
        <member name="P:H.Pipes.Args.ConnectionExceptionEventArgs`1.Exception">
            <summary>
            The exception that was thrown
            </summary>
        </member>
        <member name="M:H.Pipes.Args.ConnectionExceptionEventArgs`1.#ctor(H.Pipes.PipeConnection{`0},System.Exception)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="exception"></param>
        </member>
        <member name="T:H.Pipes.Args.ConnectionMessageEventArgs`1">
            <summary>
            Handles messages received from a named pipe.
            </summary>
            <typeparam name="T">Reference type</typeparam>
        </member>
        <member name="P:H.Pipes.Args.ConnectionMessageEventArgs`1.Message">
            <summary>
            Message sent by the other end of the pipe
            </summary>
        </member>
        <member name="M:H.Pipes.Args.ConnectionMessageEventArgs`1.#ctor(H.Pipes.PipeConnection{`0},`0)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="message"></param>
        </member>
        <member name="T:H.Pipes.Args.ExceptionEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="P:H.Pipes.Args.ExceptionEventArgs.Exception">
            <summary>
            
            </summary>
        </member>
        <member name="M:H.Pipes.Args.ExceptionEventArgs.#ctor(System.Exception)">
            <summary>
            
            </summary>
            <param name="exception"></param>
        </member>
        <member name="T:H.Pipes.Args.NameEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="P:H.Pipes.Args.NameEventArgs.Name">
            <summary>
            
            </summary>
        </member>
        <member name="M:H.Pipes.Args.NameEventArgs.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:H.Pipes.Extensions.ConnectionExtensions">
            <summary>
            Common client/server extensions
            </summary>
        </member>
        <member name="M:H.Pipes.Extensions.ConnectionExtensions.WaitMessageAsync``1(H.Pipes.IPipeConnection{``0},System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Waits for the next message asynchronously <br/>
            Returns ConnectionMessageEventArgs if message was received <br/>
            Throws <see cref="T:System.OperationCanceledException"/> if method was canceled <br/>
            </summary>
            <param name="connection"></param>
            <param name="func"></param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.OperationCanceledException"></exception>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.Extensions.ConnectionExtensions.WaitMessageAsync``1(H.Pipes.IPipeConnection{``0},System.TimeSpan,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task})">
            <summary>
            Waits for the next message asynchronously with specified timeout <br/>
            Returns DataEventArgs if message was received <br/>
            Throws <see cref="T:System.OperationCanceledException"/> if method was canceled <br/>
            </summary>
            <param name="connection"></param>
            <param name="timeout"></param>
            <param name="func"></param>
            <exception cref="T:System.OperationCanceledException"></exception>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.Extensions.EventExtensions">
            <summary>
            Extensions that work with <see langword="event"/> <br/>
            <![CDATA[Version: 1.0.0.2]]> <br/>
            </summary>
        </member>
        <member name="M:H.Pipes.Extensions.EventExtensions.WaitEventAsync``1(System.Object,System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously expects <see langword="event"/> until they occur or until canceled <br/>
            <![CDATA[Version: 1.0.0.2]]> <br/>
            <![CDATA[Dependency: WaitObject]]> <br/>
            </summary>
            <param name="value"></param>
            <param name="eventName"></param>
            <param name="cancellationToken"></param>
            <typeparam name="T">EventArgs type</typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.OperationCanceledException"></exception>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.Extensions.EventExtensions.WaitEventAsync``1(System.Object,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.String,System.Threading.CancellationToken)">
            <summary>
            Asynchronously expects <see langword="event"/> until they occur or until canceled <br/>
            <![CDATA[Version: 1.0.0.2]]> <br/>
            <![CDATA[Dependency: WaitEventAsync(this object value, string eventName, CancellationToken cancellationToken = default)]]> <br/>
            </summary>
            <param name="value"></param>
            <param name="func"></param>
            <param name="eventName"></param>
            <param name="cancellationToken"></param>
            <typeparam name="T">EventArgs type</typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.OperationCanceledException"></exception>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.Extensions.EventExtensions.WaitAllEventsAsync``1(System.Object,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.String[])">
            <summary>
            Asynchronously expects all <see langword="event"/>'s until they occur or until canceled <br/>
            This method DOES NOT throw an exception after canceling with a CancellationToken, but returns control and current results instantly <br/>
            <![CDATA[Version: 1.0.0.2]]> <br/>
            <![CDATA[Dependency: WaitEventAsync(this object value, string eventName, CancellationToken cancellationToken = default)]]> <br/>
            </summary>
            <param name="value"></param>
            <param name="func"></param>
            <param name="cancellationToken"></param>
            <param name="eventNames"></param>
            <typeparam name="T">Base type for all events</typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.Extensions.EventExtensions.WaitAnyEventAsync``1(System.Object,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken,System.String[])">
            <summary>
            Asynchronously expects any <see langword="event"/> until it occurs or until canceled <br/>
            This method DOES NOT throw an exception after canceling with a CancellationToken, but returns control and current results instantly <br/>
            <![CDATA[Version: 1.0.0.2]]> <br/>
            <![CDATA[Dependency: WaitEventAsync(this object value, string eventName, CancellationToken cancellationToken = default)]]> <br/>
            </summary>
            <param name="value"></param>
            <param name="func"></param>
            <param name="cancellationToken"></param>
            <param name="eventNames"></param>
            <typeparam name="T">Base type for all events</typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.Factories.PipeClientFactory">
            <summary>
            Internal usage
            </summary>
        </member>
        <member name="M:H.Pipes.Factories.PipeClientFactory.ConnectAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Internal usage
            </summary>
        </member>
        <member name="M:H.Pipes.Factories.PipeClientFactory.CreateAndConnectAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Internal usage
            </summary>
        </member>
        <member name="M:H.Pipes.Factories.PipeClientFactory.Create(System.String,System.String)">
            <summary>
            Internal usage
            </summary>
        </member>
        <member name="T:H.Pipes.Factories.PipeServerFactory">
            <summary>
            Internal usage
            </summary>
        </member>
        <member name="M:H.Pipes.Factories.PipeServerFactory.CreateAndWaitAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Creates new <see cref="T:System.IO.Pipes.NamedPipeServerStream"/> and waits any connection
            </summary>
            <param name="pipeName"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.Factories.PipeServerFactory.Create(System.String)">
            <summary>
            Creates new <see cref="T:System.IO.Pipes.NamedPipeServerStream"/>
            </summary>
            <param name="pipeName"></param>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.IO.PipeStreamReader">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.PipeStream"/> object and reads from it.
            </summary>
        </member>
        <member name="P:H.Pipes.IO.PipeStreamReader.IsConnected">
            <summary>
            Gets a value indicating whether the pipe is connected or not.
            </summary>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamReader.#ctor(System.IO.Pipes.PipeStream)">
            <summary>
            Constructs a new <c>PipeStreamReader</c> object that reads data from the given <paramref name="stream"/>.
            </summary>
            <param name="stream">Pipe to read from</param>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamReader.ReadLengthAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the length of the next message (in bytes) from the client.
            </summary>
            <returns>Number of bytes of data the client will be sending.</returns>
            <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
            <exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamReader.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next object from the pipe.  This method waits until an object is sent
            or the pipe is disconnected.
            </summary>
            <returns>The next object read from the pipe, or <c>null</c> if the pipe disconnected.</returns>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamReader.Dispose">
            <summary>
            Dispose internal <see cref="T:System.IO.Pipes.PipeStream"/>
            </summary>
        </member>
        <member name="T:H.Pipes.IO.PipeStreamWrapper">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.PipeStream"/> object to read and write .NET CLR objects.
            </summary>
        </member>
        <member name="P:H.Pipes.IO.PipeStreamWrapper.IsConnected">
            <summary>
                Gets a value indicating whether the <see cref="P:H.Pipes.IO.PipeStreamWrapper.BaseStream"/> object is connected or not.
            </summary>
            <returns>
                <c>true</c> if the <see cref="P:H.Pipes.IO.PipeStreamWrapper.BaseStream"/> object is connected; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:H.Pipes.IO.PipeStreamWrapper.CanRead">
            <summary>
                Gets a value indicating whether the current stream supports read operations.
            </summary>
            <returns>
                <c>true</c> if the stream supports read operations; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:H.Pipes.IO.PipeStreamWrapper.CanWrite">
            <summary>
                Gets a value indicating whether the current stream supports write operations.
            </summary>
            <returns>
                <c>true</c> if the stream supports write operations; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWrapper.#ctor(System.IO.Pipes.PipeStream)">
            <summary>
            Constructs a new <c>PipeStreamWrapper</c> object that reads from and writes to the given <paramref name="stream"/>.
            </summary>
            <param name="stream">Stream to read from and write to</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWrapper.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            Reads the next object from the pipe. 
            </summary>
            <returns>The next object read from the pipe, or <c>null</c> if the pipe disconnected.</returns>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWrapper.WriteAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Writes an object to the pipe.  This method blocks until all data is sent.
            </summary>
            <param name="buffer">Object to write to the pipe</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWrapper.StopAsync">
            <summary>
            Dispose internal <see cref="T:System.IO.Pipes.PipeStream"/>
            </summary>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWrapper.Dispose">
            <summary>
            Dispose internal <see cref="T:System.IO.Pipes.PipeStream"/>
            </summary>
        </member>
        <member name="T:H.Pipes.IO.PipeStreamWriter">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.PipeStream"/> object and writes to it.
            </summary>
        </member>
        <member name="P:H.Pipes.IO.PipeStreamWriter.BaseStream">
            <summary>
            Gets the underlying <c>PipeStream</c> object.
            </summary>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWriter.#ctor(System.IO.Pipes.PipeStream)">
            <summary>
            Constructs a new <c>PipeStreamWriter</c> object that writes to given <paramref name="stream"/>.
            </summary>
            <param name="stream">Pipe to write to</param>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWriter.WriteAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>
            Writes an object to the pipe.
            </summary>
            <param name="buffer">Object to write to the pipe</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWriter.WaitForPipeDrain">
            <summary>
            Waits for the other end of the pipe to read all sent bytes.
            </summary>
            <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
            <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
            <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
        </member>
        <member name="M:H.Pipes.IO.PipeStreamWriter.Dispose">
            <summary>
            Dispose internal <see cref="T:System.IO.Pipes.PipeStream"/>
            </summary>
        </member>
        <member name="T:H.Pipes.IPipeClient`1">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.NamedPipeClientStream"/>.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.AutoReconnect">
            <summary>
            Gets or sets whether the client should attempt to reconnect when the pipe breaks
            due to an error or the other end terminating the connection. <br/>
            Default value is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.ReconnectionInterval">
            <summary>
            Interval of reconnection.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.IsConnected">
            <summary>
            Checks that connection is exists.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.IsConnecting">
            <summary>
            <see langword="true"/> if <see cref="M:H.Pipes.IPipeClient`1.ConnectAsync(System.Threading.CancellationToken)"/> in process.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.PipeName">
            <summary>
            Used pipe name.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.ServerName">
            <summary>
            Used server name.
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeClient`1.Connection">
            <summary>
            Active connection.
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeClient`1.Connected">
            <summary>
            Invoked after each the client connect to the server (include reconnects).
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeClient`1.Disconnected">
            <summary>
            Invoked when the client disconnects from the server (e.g., the pipe is closed or broken).
            </summary>
        </member>
        <member name="M:H.Pipes.IPipeClient`1.ConnectAsync(System.Threading.CancellationToken)">
            <summary>
            Connects to the named pipe server asynchronously.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:H.Pipes.IPipeClient`1.DisconnectAsync(System.Threading.CancellationToken)">
            <summary>
            Disconnects from server
            </summary>
            <param name="_"></param>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.IPipeConnection`1">
            <summary>
            Base class of all connections
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.IPipeConnection`1.Formatter">
            <summary>
            Used formatter
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeConnection`1.MessageReceived">
            <summary>
            Invoked whenever a message is received.
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeConnection`1.ExceptionOccurred">
            <summary>
            Invoked whenever an exception is thrown during a read or write operation on the named pipe.
            </summary>
        </member>
        <member name="M:H.Pipes.IPipeConnection`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Sends a message over a named pipe. <br/>
            </summary>
            <param name="value">Message to send</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:H.Pipes.IPipeServer`1">
            <summary>
            
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.IPipeServer`1.PipeName">
            <summary>
            Name of pipe
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeServer`1.CreatePipeStreamFunc">
            <summary>
            CreatePipeStreamFunc
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeServer`1.PipeStreamInitializeAction">
            <summary>
            PipeStreamInitializeAction
            </summary>
        </member>
        <member name="P:H.Pipes.IPipeServer`1.IsStarted">
            <summary>
            IsStarted
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeServer`1.ClientConnected">
            <summary>
            Invoked whenever a client connects to the server.
            </summary>
        </member>
        <member name="E:H.Pipes.IPipeServer`1.ClientDisconnected">
            <summary>
            Invoked whenever a client disconnects from the server.
            </summary>
        </member>
        <member name="M:H.Pipes.IPipeServer`1.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Begins listening for client connections in a separate background thread.
            This method waits when pipe will be created(or throws exception).
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:H.Pipes.IPipeServer`1.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Closes all open client connections and stops listening for new ones.
            </summary>
        </member>
        <member name="T:H.Pipes.PipeClient`1">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.NamedPipeClientStream"/>.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.PipeClient`1.AutoReconnect">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.ReconnectionInterval">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.IsConnected">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.IsConnecting">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.Formatter">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.PipeName">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.ServerName">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.PipeClient`1.Connection">
            <inheritdoc/>
        </member>
        <member name="E:H.Pipes.PipeClient`1.MessageReceived">
            <summary>
            Invoked whenever a message is received from the server.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeClient`1.Disconnected">
            <summary>
            Invoked when the client disconnects from the server (e.g., the pipe is closed or broken).
            </summary>
        </member>
        <member name="E:H.Pipes.PipeClient`1.Connected">
            <summary>
            Invoked after each the client connect to the server (include reconnects).
            </summary>
        </member>
        <member name="E:H.Pipes.PipeClient`1.ExceptionOccurred">
            <summary>
            Invoked whenever an exception is thrown during a read or write operation on the named pipe.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeClient`1.#ctor(System.String,System.String,System.Nullable{System.TimeSpan},H.Formatters.IFormatter)">
            <summary>
            Constructs a new <see cref="T:H.Pipes.PipeClient`1"/> to connect to the <see cref="T:H.Pipes.PipeServer`1"/> specified by <paramref name="pipeName"/>. <br/>
            Default reconnection interval - <see langword="100 ms"/>
            </summary>
            <param name="pipeName">Name of the server's pipe</param>
            <param name="serverName">the Name of the server, default is  local machine</param>
            <param name="reconnectionInterval">Default reconnection interval - <see langword="100 ms"/></param>
            <param name="formatter">Default formatter - <see cref="T:H.Formatters.BinaryFormatter"/></param>
        </member>
        <member name="M:H.Pipes.PipeClient`1.ConnectAsync(System.Threading.CancellationToken)">
            <summary>
            Connects to the named pipe server asynchronously.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:H.Pipes.PipeClient`1.DisconnectAsync(System.Threading.CancellationToken)">
            <summary>
            Disconnects from server
            </summary>
            <param name="_"></param>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.PipeClient`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Sends a message to the server over a named pipe. <br/>
            If client is not connected, <see cref="T:System.InvalidOperationException"/> is occurred
            </summary>
            <param name="value">Message to send to the server.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:H.Pipes.PipeClient`1.DisposeAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="M:H.Pipes.PipeClient`1.GetConnectionPipeName(System.Threading.CancellationToken)">
            <summary>
            Get the name of the data pipe that should be used from now on by this NamedPipeClient
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.PipeConnection`1">
            <summary>
            Represents a connection between a named pipe client and server.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.PipeName">
            <summary>
            Gets the connection's pipe name.
            </summary>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.ServerName">
            <summary>
            Gets the connection's server name. Only for client connections.
            </summary>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.IsConnected">
            <summary>
            Gets a value indicating whether the pipe is connected or not.
            </summary>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.IsStarted">
            <summary>
            <see langword="true"/> if started and not disposed.
            </summary>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.PipeStream">
            <summary>
            Raw pipe stream. You can cast it to <see cref="T:System.IO.Pipes.NamedPipeClientStream"/> or <see cref="T:System.IO.Pipes.NamedPipeServerStream"/>.
            </summary>
        </member>
        <member name="P:H.Pipes.PipeConnection`1.Formatter">
            <summary>
            Used formatter.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeConnection`1.Disconnected">
            <summary>
            Invoked when the named pipe connection terminates.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeConnection`1.MessageReceived">
            <summary>
            Invoked whenever a message is received from the other end of the pipe.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeConnection`1.ExceptionOccurred">
            <summary>
            Invoked when an exception is thrown during any read/write operation over the named pipe.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeConnection`1.Start">
            <summary>
            Begins reading from and writing to the named pipe on a background thread.
            This method returns immediately.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeConnection`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Writes the specified <paramref name="value"/> and waits other end reading
            </summary>
            <param name="value"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.PipeConnection`1.StopAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="M:H.Pipes.PipeConnection`1.GetImpersonationUserName">
            <summary>
            Gets the user name of the client on the other end of the pipe.
            </summary>
            <returns>The user name of the client on the other end of the pipe.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:H.Pipes.PipeConnection`1.PipeStream"/> is not <see cref="T:System.IO.Pipes.NamedPipeServerStream"/>.</exception>
            <exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.</exception>
            <exception cref="T:System.InvalidOperationException">The connected pipe has already disconnected.</exception>
            <exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception>
            <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
            <exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception>
            <exception cref="T:System.IO.IOException">The user name of the client is longer than 19 characters.</exception>
        </member>
        <member name="M:H.Pipes.PipeConnection`1.DisposeAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="T:H.Pipes.PipeServer`1">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.NamedPipeServerStream"/> and provides multiple simultaneous client connection handling.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.PipeServer`1.PipeName">
            <summary>
            Name of pipe
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.CreatePipeStreamFunc">
            <summary>
            CreatePipeStreamFunc
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.PipeStreamInitializeAction">
            <summary>
            PipeStreamInitializeAction
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.Formatter">
            <summary>
            Used formatter
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.WaitFreePipe">
            <summary>
            Indicates whether to wait for a name to be released when calling StartAsync()
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.Connections">
            <summary>
            All connections(include disconnected clients)
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.ConnectedClients">
            <summary>
            Connected clients
            </summary>
        </member>
        <member name="P:H.Pipes.PipeServer`1.IsStarted">
            <summary>
            IsStarted
            </summary>
        </member>
        <member name="E:H.Pipes.PipeServer`1.ClientConnected">
            <summary>
            Invoked whenever a client connects to the server.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeServer`1.ClientDisconnected">
            <summary>
            Invoked whenever a client disconnects from the server.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeServer`1.MessageReceived">
            <summary>
            Invoked whenever a client sends a message to the server.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeServer`1.ExceptionOccurred">
            <summary>
            Invoked whenever an exception is thrown during a read or write operation.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeServer`1.#ctor(System.String,H.Formatters.IFormatter)">
            <summary>
            Constructs a new <c>NamedPipeServer</c> object that listens for client connections on the given <paramref name="pipeName"/>.
            </summary>
            <param name="pipeName">Name of the pipe to listen on</param>
            <param name="formatter">Default formatter - <see cref="T:H.Formatters.BinaryFormatter"/></param>
        </member>
        <member name="M:H.Pipes.PipeServer`1.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Begins listening for client connections in a separate background thread.
            This method waits when pipe will be created(or throws exception).
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:H.Pipes.PipeServer`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Sends a message to all connected clients asynchronously.
            This method returns immediately, possibly before the message has been sent to all clients.
            </summary>
            <param name="value"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.PipeServer`1.WriteAsync(`0,System.Predicate{H.Pipes.PipeConnection{`0}},System.Threading.CancellationToken)">
            <summary>
            Sends a message to all connected clients asynchronously.
            </summary>
            <param name="value"></param>
            <param name="predicate"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.PipeServer`1.WriteAsync(`0,System.String,System.Threading.CancellationToken)">
            <summary>
            Sends a message to the given client by pipe name.
            </summary>
            <param name="value"></param>
            <param name="pipeName"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.PipeServer`1.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Closes all open client connections and stops listening for new ones.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeServer`1.DisposeAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="T:H.Pipes.PipeWatcher">
            <summary>
            Watches the directory "\\.\pipe\" and reports on new events
            <![CDATA[!!! WARNING: Use it carefully, it is very slow !!!]]>
            </summary>
        </member>
        <member name="P:H.Pipes.PipeWatcher.IsStarted">
            <summary>
            Returns <see langword="true"/> if <see cref="T:H.Pipes.PipeWatcher"/> is active
            </summary>
        </member>
        <member name="E:H.Pipes.PipeWatcher.Created">
            <summary>
            When any pipe created.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeWatcher.Deleted">
            <summary>
            When any pipe deleted.
            </summary>
        </member>
        <member name="E:H.Pipes.PipeWatcher.ExceptionOccurred">
            <summary>
            When any exception is thrown.
            </summary>
        </member>
        <member name="M:H.Pipes.PipeWatcher.#ctor(System.Nullable{System.TimeSpan})">
            <summary>
            Create new instance of watcher <br/>
            Default interval is <see langword="100 milliseconds"/>
            </summary>
            <param name="interval"></param>
        </member>
        <member name="M:H.Pipes.PipeWatcher.Start">
            <summary>
            Starts watching
            </summary>
        </member>
        <member name="M:H.Pipes.PipeWatcher.Stop">
            <summary>
            Stops watching(without disposing) <br/>
            You can call <see cref="M:H.Pipes.PipeWatcher.Start"/> again if it is required
            </summary>
        </member>
        <member name="M:H.Pipes.PipeWatcher.Dispose">
            <summary>
            Dispose internal <see cref="P:H.Pipes.PipeWatcher.Timer"/>
            </summary>
        </member>
        <member name="M:H.Pipes.PipeWatcher.IsExists(System.String)">
            <summary>
            Checks if a given pipe name exists
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.PipeWatcher.GetActivePipes">
            <summary>
            Returns list of active pipes
            </summary>
        </member>
        <member name="M:H.Pipes.PipeWatcher.CreateAndStart(System.Nullable{System.TimeSpan})">
            <summary>
            Create new instance of watcher and start it<br/>
            Default interval is <see langword="100 milliseconds"/>
            </summary>
            <param name="interval"></param>
            <returns></returns>
        </member>
        <member name="T:H.Pipes.SingleConnectionPipeClient`1">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.NamedPipeClientStream"/>.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.AutoReconnect">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.ReconnectionInterval">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.IsConnected">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.IsConnecting">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.Formatter">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.PipeName">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.ServerName">
            <inheritdoc/>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeClient`1.Connection">
            <inheritdoc/>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeClient`1.MessageReceived">
            <summary>
            Invoked whenever a message is received from the server.
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeClient`1.Disconnected">
            <summary>
            Invoked when the client disconnects from the server (e.g., the pipe is closed or broken).
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeClient`1.Connected">
            <summary>
            Invoked after each the client connect to the server (include reconnects).
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeClient`1.ExceptionOccurred">
            <summary>
            Invoked whenever an exception is thrown during a read or write operation on the named pipe.
            </summary>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeClient`1.#ctor(System.String,System.String,System.Nullable{System.TimeSpan},H.Formatters.IFormatter)">
            <summary>
            Constructs a new <see cref="T:H.Pipes.PipeClient`1"/> to connect to the <see cref="T:H.Pipes.PipeServer`1"/> specified by <paramref name="pipeName"/>. <br/>
            Default reconnection interval - <see langword="100 ms"/>
            </summary>
            <param name="pipeName">Name of the server's pipe</param>
            <param name="serverName">the Name of the server, default is  local machine</param>
            <param name="reconnectionInterval">Default reconnection interval - <see langword="100 ms"/></param>
            <param name="formatter">Default formatter - <see cref="T:H.Formatters.BinaryFormatter"/></param>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeClient`1.ConnectAsync(System.Threading.CancellationToken)">
            <summary>
            Connects to the named pipe server asynchronously.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeClient`1.DisconnectAsync(System.Threading.CancellationToken)">
            <summary>
            Disconnects from server
            </summary>
            <param name="_"></param>
            <returns></returns>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeClient`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Sends a message to the server over a named pipe. <br/>
            If client is not connected, <see cref="T:System.InvalidOperationException"/> is occurred
            </summary>
            <param name="value">Message to send to the server.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeClient`1.DisposeAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="T:H.Pipes.SingleConnectionPipeServer`1">
            <summary>
            Wraps a <see cref="T:System.IO.Pipes.NamedPipeServerStream"/> and optimized for one connection.
            </summary>
            <typeparam name="T">Reference type to read/write from the named pipe</typeparam>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.PipeName">
            <summary>
            Name of pipe
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.CreatePipeStreamFunc">
            <summary>
            CreatePipeStreamFunc
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.PipeStreamInitializeAction">
            <summary>
            PipeStreamInitializeAction
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.Formatter">
            <summary>
            Used formatter
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.WaitFreePipe">
            <summary>
            Indicates whether to wait for a name to be released when calling StartAsync()
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.Connection">
            <summary>
            Connection
            </summary>
        </member>
        <member name="P:H.Pipes.SingleConnectionPipeServer`1.IsStarted">
            <summary>
            IsStarted
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeServer`1.ClientConnected">
            <summary>
            Invoked whenever a client connects to the server.
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeServer`1.ClientDisconnected">
            <summary>
            Invoked whenever a client disconnects from the server.
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeServer`1.MessageReceived">
            <summary>
            Invoked whenever a client sends a message to the server.
            </summary>
        </member>
        <member name="E:H.Pipes.SingleConnectionPipeServer`1.ExceptionOccurred">
            <summary>
            Invoked whenever an exception is thrown during a read or write operation.
            </summary>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeServer`1.#ctor(System.String,H.Formatters.IFormatter)">
            <summary>
            Constructs a new <c>NamedPipeServer</c> object that listens for client connections on the given <paramref name="pipeName"/>.
            </summary>
            <param name="pipeName">Name of the pipe to listen on</param>
            <param name="formatter">Default formatter - <see cref="T:H.Formatters.BinaryFormatter"/></param>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeServer`1.StartAsync(System.Threading.CancellationToken)">
            <summary>
            Begins listening for client connections in a separate background thread.
            This method waits when pipe will be created(or throws exception).
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeServer`1.WriteAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Sends a message to all connected clients asynchronously.
            </summary>
            <param name="value"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeServer`1.StopAsync(System.Threading.CancellationToken)">
            <summary>
            Closes all open client connections and stops listening for new ones.
            </summary>
        </member>
        <member name="M:H.Pipes.SingleConnectionPipeServer`1.DisposeAsync">
            <summary>
            Dispose internal resources
            </summary>
        </member>
        <member name="T:H.Pipes.Utilities.TaskWorker">
            <summary>
            A class designed to run code using <see cref="P:H.Pipes.Utilities.TaskWorker.Task"/> with <see cref="F:System.Threading.Tasks.TaskCreationOptions.LongRunning"/> <br/>
            and supporting automatic cancellation after <see cref="M:H.Pipes.Utilities.TaskWorker.DisposeAsync"/> <br/>
            <![CDATA[Version: 1.0.0.6]]> <br/>
            </summary>
        </member>
        <member name="P:H.Pipes.Utilities.TaskWorker.Task">
            <summary>
            Internal task
            </summary>
        </member>
        <member name="P:H.Pipes.Utilities.TaskWorker.CancellationTokenSource">
            <summary>
            Internal task CancellationTokenSource
            </summary>
        </member>
        <member name="M:H.Pipes.Utilities.TaskWorker.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Action{System.Exception})">
            <summary>
            Creates and starts <see cref="T:H.Pipes.Utilities.TaskWorker"/>
            </summary>
            <param name="action"></param>
            <param name="exceptionAction"></param>
        </member>
        <member name="M:H.Pipes.Utilities.TaskWorker.StopAsync">
            <summary>
            Cancel task(if it's not completed) and dispose internal resources <br/>
            </summary>
        </member>
        <member name="M:H.Pipes.Utilities.TaskWorker.DisposeAsync">
            <summary>
            Cancel task(if it's not completed) and dispose internal resources <br/>
            </summary>
        </member>
    </members>
</doc>
